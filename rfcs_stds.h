#ifndef RFCS_STDS_H
#define RFCS_STDS_H

#include "netmask.h"

namespace __check_rfc__
{
//=========== Согласно RFC 5737 приведенные адреса зарезервированы для документации =========================
/* Три блока адресов IPv4, предназначенных для использования в документации.
   Сетевым операторам следует добавить эти блоки адресов в число немаршрутизируемых,
   а при использовании пакетных фильтров следует добавить эти адреса в списки фильтрации.
   Блоки адресов не предназначены для локального использования и фильтры могут
   применяться как в локальном, так и в публичном контексте.

   Блоки адресов для документации:
        192.0.2.0/24 (TEST-NET-1),
        198.51.100.0/24 (TEST-NET-2),
        203.0.113.0/24 (TEST-NET-3)*/
    const QVector<IPrecord>RFC_5737 = {IPrecord(192, 0, 2, 0),
                                   IPrecord(198, 51, 100, 0),
                                   IPrecord(203, 0, 113, 0)};
    const unsigned short RFC_5737_b = 24;
//===========================================================================================================

//=========== Согласно RFC 1918 приведенные адреса являются частными =======================================
// Блоки частных(серых) адресов:
// 10.0.0.0        -   10.255.255.255  (10/8 prefix)
// 172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
// 192.168.0.0     -   192.168.255.255 (192.168/16 prefix)
    const QVector<IPrecord> RFC_1918 = {IPrecord(10, 0, 0, 0),
                                  IPrecord(172, 16, 0, 0),
                                  IPrecord(192, 168, 0, 0)};
    const QVector<unsigned short> RFC_1918_bs = {8, 12, 16};
//===========================================================================================================

//=========== Согласно RFC 3068 =============================================================================
/* 6to4 — это переходный механизм,
 * позволяющий передавать IPv6-пакеты через IPv4-сети и не требующий
 * создания двусторонних туннелей.
 * Это, как правило, используется, когда конечный пользователь
 * или сайт хотят получить соединение с IPv6-Интернетом,
 * но не могут получить его от провайдера.

 * Для того чтобы 6to4-узлы могли отправлять пакеты в другие IPv6-сети,
 * были созданы 6to4-ретрансляторы, которые подключены как к IPv4-сети,
 * так и к IPv6-сети.
 * Когда 6to4-узлу нужно отправить IPv6-пакет, он отправляет его
 * по anycast адресу 192.88.99.1. Ретранслятор, получив 6to4-пакет,
 * извлекает IPv6-пакет и отправляет его по IPv6-сети. Для IPv6-узлов 6to4-узлы выглядят,
 * как обычные IPv6-узлы и IPv6-пакет будет передан на ближайший 6to4-ретранслятор,
 * анонсирующий префикс сети 2002::/16.
 * Например,
 * IPv4: 192.0.2.4 --> IPv6: 2002:c000:0204::/48

 * 192.88.99.1 необходим для доступа к ближайшему ретранслятору 6to4 anycast
 */

    const IPrecord RFC_3068 = IPrecord(192, 88, 99, 0);
    const unsigned short RFC_3068_b = 24;

/*
 * RFC 3068 и 6732 были перемещены в Исторический
 * статус
*/

//===========================================================================================================

//============ Согласно RFC 3927 ============================================================================
/* Динамическая настройка локальных адресов IPv4
 *
 * Link-Local Address — адреса сети,
 * которые предназначены только для коммуникаций в пределах одного
 * сегмента местной сети или магистральной линии. Они позволяют обращаться
 * к хостам, не используя общий префикс адреса.
 *
 * Подсети link-local не маршрутизируются: маршрутизаторы не должны отправлять
 * пакеты с адресами link-local в другие сети.
 * Адреса link-local часто используются для автоматического конфигурирования сетевого адреса,
 * в случаях, когда внешние источники информации об адресах сети недоступны.
 *
 * Типичное использование link-local адресов — автоматическое конфигурирование IP-адресов
 * в локальных сетях Ethernet. Адрес из диапазона link-local назначается ОС хоста автоматически
 * в случае недоступности других источников информации, например сервера DHCP.
 */

    const IPrecord RFC_3927 = IPrecord(169, 254, 0, 0);
    const unsigned short RFC_3927_b = 16;
//===========================================================================================================

//=========== Согласно RFC 1122 =============================================================================
/*
 * 0.0.0.0/8
 * Диапазон описан в RFC1122 , RFC3330 и RFC1700 как "Этот хост в этой сети"
 * (this host on this network), хотя, учитывая варианты применения, правильнее
 * было бы назвать его как "любой адрес". В частности, IP-адрес 0.0.0.0 используется для:
 * - обозначения в конфигурационных файлах серверов и выводе netstat информации о том, что определенный
 * сервис "слушает" запросы на всех IP-адресах данного сервера;
 * - конфигурации маршрута по умолчанию на активном сетевом оборудовании;
 * - использования в качестве src address в запросах на получение IP-адреса (DHCPDISCOVER);
 * - обозначения IP-адреса в суммаризованных событиях безопасности IDS/IPS/WAF/etc
 * (например, TCP Host Sweep - обозначение dst host в случае инициации коннектов к большому количеству IP-адресов).
 *
 *
 * 127.0.0.0/8
 * В случае, если сервису необходим для работы функционирующий сетевой стек,
 * который не будет давать сбоев при отключении от сети, используются loopback-адреса.
 * Выделение 127.0.0.0/8 под внутренние loopback-адреса определено в RFC1122 .
 * В отличие от адресов RFC1918 и RFC6598, адреса для loopback не должны присутствовать
 * и обрабатываться ни в одной сети, только во внутренней таблице маршрутизации хоста.
*/
/*
 * 240.0.0.0/4
 * В соответствии с RFC1122 ,
 * данный диапазон IP-адресов, исторически также известный как Class E,
 * зарезервирован под использование в будущем.
*/

    const QVector<IPrecord> RFC_1122 = {IPrecord(0, 0, 0, 0),
                                  IPrecord(127, 0, 0, 0),
                                  IPrecord(240, 0, 0, 0)};
    const QVector<unsigned short> RFC_1122_bs = {8, 8, 4};
//===========================================================================================================

//=========== Согласно RFC 2544 =============================================================================
/*
 * 198.18.0.0/15
 * Диапазон выделен под лаборатории нагрузочного тестирования (Benchmarking)
 * в соответствии с RFC2544 и уточнением в RFC6815 , что данный диапазон не должен
 * быть досутпен в Интернет во избежание конфликтов. Опять же, никто при этом не отменяет
 * использование RFC1918, но для больших сетей с крупными лабораториями лишний блок /15 явно не помешает.
*/
    const IPrecord RFC_2544 = IPrecord(198, 18, 0, 0);
    const unsigned short RFC_2544_b = 15;
//===========================================================================================================

//=========== Согласно RFC 3171 =============================================================================
/*
 * 224.0.0.0/4
 * Этот диапазон в исторической классификации еще называется как Class D. Выделен под Multicast,
 * уточнение специфики работы которого тоже вроде как отдельная заметка. В RFC5771 подробно расписано
 * использование подсетей внутри блока, но суть остается той же: эти адреса не закреплены ни за каким провайдером,
 * и, соответственно, через Интернет не должны светиться.
*/
    const IPrecord RFC_3171 = IPrecord(224, 0, 0, 0);
    const unsigned short RFC_3171_b = 4;
//===========================================================================================================

//=========== Согласно RFC 8190 =============================================================================
/*
 * 255.255.255.255/32
 * Адрес назначения «ограниченное вещание»
*/

//    IPrecord RFC_8190 = IPrecord(255, 255, 255, 255);
//    NetMask RFC_8190_m = NetMask(32);
//===========================================================================================================

    enum RFC_ERROR {RFC_5737_ERROR, RFC_1918_ERROR, RFC_3068_ERROR, RFC_3927_ERROR, RFC_1122_ERROR, RFC_2544_ERROR, RFC_3171_ERROR};

    bool check_line(const IPrecord &rfc, unsigned short rfc_b, const IPrecord &net_address);
    bool check_block(const QVector<IPrecord> &rfc, const QVector<unsigned short> &rfc_bs,
                     const IPrecord &net_address);

    bool check_rfc5737(const IPrecord &net_address);
    bool check_rfc1918(const IPrecord &net_address);
    bool check_rfc3068(const IPrecord &net_address);
    bool check_rfc3927(const IPrecord &net_address);
    bool check_rfc1122(const IPrecord &net_address);
    bool check_rfc2544(const IPrecord &net_address);
    bool check_rfc3171(const IPrecord &net_address);
    bool check_rfc(const IPrecord &net_address);
    bool check_rfc_with_error(const IPrecord &net_address);
}

#endif // RFCS_STDS_H
